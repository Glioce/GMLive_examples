<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_pj</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>2</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>msk_pj</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>scr_create(sprite_index);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// IA Torso Inicializar
/******************************************************************************
A* FOR PLATFORMER V0.2
Modified version of previous A* implementation.
Nodes are created over platforms only.
Following pseudo-code from Wikipedia.
The best g score is the time needed to move the character to the next node.
********************************************************************************/

// Variables
cols = 50; //room_width / 16; //columns
rows = 30; //13; //rows
w = 16; //cell width
h = 16; //cell height
w2 = w/2; //la mitad
h2 = h/2;
// platofrms and nodes are inserted in the same grid
grid = ds_grid_create(cols, rows); //nodes grid

// Init grid
empty = -2; // value asigned to empty cells
wall = -1; // value asigned to walls
for (i = 0; i &lt; cols; i++)
for (j = 0; j &lt; rows; j++) {
    xx = i * w; //coordenadas para revisar
    yy = j * h;
    if position_meeting(xx, yy, obj_wall)
      ds_grid_set(grid, i, j, wall);
    else
      ds_grid_set(grid, i, j, empty);
}

// Goal node
o = obj_checkpoint;
goal = ds_map_create();
goal[?"x"] = o.x/16; //horizontal pos in grid
goal[?"y"] = o.y/16; //vertical pos in grid
goal[?"g"] = -1; //g score not calculated
goal[?"f"] = -1; //f score not calculated
goal[?"from"] = -1; //came from
goal[?"ne"] = ds_list_create(); //list of neighbors
repeat(5) ds_list_add(goal[?"ne"], -1);
ds_grid_set(grid, goal[?"x"], goal[?"y"], goal); //insert in grid

// Start node
start = ds_map_create();
start[?"x"] = floor(x/16); //horizontal pos in grid
start[?"y"] = floor(y/16); //vertical pos in grid
start[?"g"] = 0; //initial cost
start[?"f"] = 0 + point_distance(
   start[?"x"], start[?"y"], goal[?"x"], goal[?"y"]); //f score    
start[?"from"] = -1; //came from (unknown)
start[?"ne"] = ds_list_create(); //list of neighbors
repeat(5) ds_list_add(start[?"ne"], -1);
ds_grid_set(grid, start[?"x"], start[?"y"], start); //insert in grid

// Nodes over platforms
for (i = 0; i &lt; cols; i++)
for (j = 1; j &lt; rows; j++) {
    if (ds_grid_get(grid, i, j) == wall) {//create nodes
        for (k = -1; k &lt;= 1; k++) {
            xx = i + k;
            yy = j - 1;
            // if position is valid (within grid and empty)
            if (xx &gt;=0 and xx &lt; cols and yy &gt;= 0 and yy &lt; rows
            and ds_grid_get(grid, i, yy) &lt;&gt; wall
            and ds_grid_get(grid, xx, yy) == empty) {
                node = ds_map_create();
                node[?"x"] = xx; //horizontal pos
                node[?"y"] = yy; //vertical pos
                node[?"f"] = -1; //f score not calculated
                node[?"g"] = -1; //g score not calculated
                node[?"from"] = -1; //came from
                node[?"ne"] = ds_list_create(); //list of neighbors
                repeat(5) ds_list_add(node[?"ne"], -1);
                ds_grid_set(grid, xx, yy, node); //insert in grid
                //show_debug_message(string(node)+" "+string(xx)+" "+string(yy));
            }
        }
    }
}

// Find neighbors
// Cada nodo intenta buscar 5 vecinos.
// Si hay un bloque debajo del nodo, solo busca nodos a los lados
// Si no hay un bloque debajo, busca a los lados, abajo y en diagonales
// abajo a la izquierda y abajo a la derecha. La línea puede extenderse mucho
// hasta encontrar un nodo en diagonal.
// 0: derecha
// 1: izquierda
// 2: abajo
// 3: abajo_derecha
// 4: abajo_izquierda

for (i = 0; i &lt; cols; i++)
for (j = 0; j &lt; rows; j++) {
    node = ds_grid_get(grid, i, j);
    if (node &gt;= 0) {
        list = node[?"ne"]; //obtener la lista de vecinos
        
        // buscar nodos a los lados

        //show_debug_message(string(node)+" "+string(list[|0]));
        if (list[|0] &lt; 0) //si no se ha asignado vecino a la derecha
        // buscar vecino sin salir de la grid y hasta 6 celdas a la derecha
        for (xx = i+1; xx &lt; cols and xx &lt;= i+6; xx++) {
            val = ds_grid_get(grid, xx, j); //valor de celda
            if (val &gt;= 0) {//si es un nodo
                list[|0] = val; //guardar vecino (a la derecha)
                l = val[?"ne"]; //obtener lista del vecino
                l[|1] = node; //el nodo actual también es un un vecino
                //show_debug_message("derecha");
                break; //terminar ciclo
            }
            if (val == wall) break; //si es un bloque, también terminar ciclo
        }
        
        /*if (list[|1] &lt; 0) //si no se ha asignado vecino a la izquierda
        // buscar vecino sin salir de la grid y hasta 6 celdas a la izquierda
        for (xx = i-1; xx &gt;= 0 and xx &gt;= i-6; xx--) {
            val = ds_grid_get(grid, xx, j); //valor de celda
            if (val &gt;= 0) {//si es un nodo
                list[|1] = val; //guardar vecino (a la izquierda)
                l = val[?"ne"]; //obtener lista del vecino
                l[|0] = node; //el nodo actual también es un un vecino
                //show_debug_message("izquierda");
                break; //terminar ciclo
            }
            if (val == wall) break; //si es un bloque, también terminar ciclo
        }*/
        
        // si hay un bloque debajo, no buscar vecinos abajo
        if (ds_grid_get(grid, i, j+1) &lt;&gt; wall) {
            for (yy = j+1; yy &lt; rows; yy++) {
                val = ds_grid_get(grid, i, yy);
                // si es un nodo que tiene un bloque debajo
                if (val &gt;= 0 and ds_grid_get(grid, i, yy+1) == wall)
                or (val == goal) {
                    list[|2] = val; //guardar vecino (abajo)
                    l = val[?"ne"]; //obtener lista del vecino
                    ds_list_add(l, node); //agregar nodo actual como vecino
                    break; //terminar ciclo
                }
                if (val == wall) break; //si es un bloque, también terminar ciclo
            }
        }
    }
}

// Crate open set
openSet = ds_priority_create(); //discovered nodes
// Initially, only start is known
ds_priority_add(openSet, start, start[?"f"]);

//done = false; //algorithm can keep going
/*list = start[?"ne"];
len = ds_list_size(list)
for (i = 0; i &lt; len; i++)
show_debug_message(list[|i]);

node = 5;
list = node[?"ne"];
len = ds_list_size(list)
for (i = 0; i &lt; len; i++)
show_debug_message(list[|i]);

show_debug_message(start[?"x"]);
show_debug_message(start[?"y"]);
*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>scr_alrm0();</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>scr_end_step();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>scr_begin_step();</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// IA Torso Avanzar

//scr_walk(1);
if keyboard_check_pressed(vk_up) {scr_salto();}
if keyboard_check(vk_right) {scr_walk(1);}
if keyboard_check(vk_left) {scr_walk(-1);}

if keyboard_check_pressed(vk_numpad0) {
   switch (room_speed) {
      case 60: room_speed = 30; break;
      case 30: room_speed = 1; break;
      case 1: room_speed = 60; break;
   }
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>scr_step();</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_wall">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>scr_col_wall();</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_global_pinches">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>scr_col_pinches();</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_almoada">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>scr_col_almoada();</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_trampolin">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>scr_col_trampolin();</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Destruir todas las estructuras de datos

// listas
z = ds_list_create(); //nuevo index
for (i = 0; i &lt;= z; i++) ds_list_destroy(i);

// maps
z = ds_map_create(); //nuevo index
for (i = 0; i &lt;= z; i++) ds_map_destroy(i);

// grids
ds_grid_destroy(grid);

// queues
ds_priority_destroy(openSet);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="73">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// IA Torso Depurar
/****************************************
*****************************************/

draw_set_font(fontTorsoDebug);

// Draw grid
// walls
//draw_set_color(c_white);
for (i = 0; i &lt; cols; i++)
for (j = 0; j &lt; rows; j++) {
    xx = i * w;
    yy = j * h;
    z = ds_grid_get(grid, i, j);
    if (z == wall)
      draw_rectangle(xx, yy, xx+4, yy+4, false);
      //draw_text(xx, yy, "O");
}
// g and f values
//draw_set_color(c_black);
/*for (i = 0; i &lt; cols; i++)
for (j = 0; j &lt; rows; j++) {
    xx = i * w;
    yy = j * h;
    z = ds_grid_get(grid, i, j);
    if (z &gt;= 0) {
        draw_text(xx, yy, z[?"g"]);
        //draw_text(xx, yy+6, z[?"f"]);
        //draw_text(xx, yy, string_format(z[?"g"], 0, 1));
        draw_text(xx, yy+6, string_format(z[?"f"], 0, 1));
    }
}*/
// ids de los nodos
//draw_set_color(c_black);
for (i = 0; i &lt; cols; i++)
for (j = 0; j &lt; rows; j++) {
    z = ds_grid_get(grid, i, j);
    if (z &gt;= 0) {
        xx = i * w;
        yy = j * h;
        draw_text(xx, yy, z);
    }
}
// conections to neighbors
draw_set_color(c_lime);
//draw_line(0, 0, room_width, room_height);
for (i = 0; i &lt; cols; i++)
for (j = 0; j &lt; rows; j++) {
    x1 = (i * w) + w2; //position in pixels
    y1 = (j * h) + h2;
    z = ds_grid_get(grid, i, j);
    //if (z == 5) continue;
    if (z &gt;= 0) {//si es un nodo
        list = z[?"ne"]; //obtener lista de vecinos
        len = ds_list_size(list); //cantidad de vecinos
        for (k = 0; k &lt; len; k++) {//revisar cada vecino
            vecino = list[|k]; //id del vecino
            if (vecino &gt;= 0) {
                x2 = (vecino[?"x"] * w) + w2;
                y2 = (vecino[?"y"] * h) + h2;
                a = point_direction(x1, y1, x2, y2);
                dx = lengthdir_x(2, a+90);
                dy = lengthdir_y(2, a+90);
                draw_line(x1+dx, y1+dy, x2+dx, y2+dy);
                //draw_line(x1, y1, x2, y2);
            }
        }
    }
}
// path
/*draw_set_color(c_red);
for (i = 0; i &lt; cols; i++)
for (j = 0; j &lt; rows; j++) {
    x = i * w + w2;
    y = j * h + h2;
    z = ds_grid_get(grid, i, j);
    if (z &gt;= 0) {
        from = z[?"from"];
        if (from &lt;&gt; -1) {
            draw_line(x, y, from[?"x"]*w+w2, from[?"y"]*h+h2);
        }
    }
}*/

// Draw openSet
xx = 10;
yy = 50;
draw_set_color(c_lime);
draw_text(xx, yy, ds_priority_size(openSet));
draw_text(xx, yy+8, ds_priority_find_min(openSet));
draw_text(xx, yy+16, ds_priority_find_max(openSet));

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>425</id>
        <kind>4</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>scr_draw();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
